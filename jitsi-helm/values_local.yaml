# Default values for jitsi-meet.

# This is a YAML-formatted file.

# Declare variables to be passed into your templates.



global:

  podLabels: {}

  podAnnotations: {}

imagePullSecrets:
  - name: awsecr-cred

nameOverride: ""

fullnameOverride: ""



enableAuth: true

enableGuests: true

publicURL: "http://127.0.0.1:8443"




tz: Asia/Calcutta



image:

  pullPolicy: IfNotPresent



web:

  replicaCount: 1

  image:

    repository: 660124699787.dkr.ecr.ap-south-1.amazonaws.com/video-conferencing #jitsi/web
    tag: presetPassword3.0 #"stable-6433"


  extraEnvs:
    NSLHUB_CDM_ENV: "paas3"
    NSLHUB_IAM_ENV: "paas3"
    NSLHUB_PROSODY_USER_NAME: "support"
    NSLHUB_PROSODY_USER_PASSWORD: "support"
    NSLHUB_VIDEO_CONFERENCING_FEATURE_NAME: "VideoConferencing"
    NSLHUB_VIDEO_CONFERENCING_ROLE: "Moderator"
    NSLHUB_DEV_HOST: "localhost:8443" #"jitsi-dev"
    NSLHUB_DEFAULT_TENANT: "jitsitesting"
    ENABLE_PREJOIN_PAGE: "1"
    ETHERPAD_URL_BASE: http://etherpad-service.qa3:9001
  service:

    type: ClusterIP
    
    port: 80

    externalIPs: []



  ingress:

    enabled: false

    annotations: {}

      # kubernetes.io/ingress.class: nginx

      # kubernetes.io/tls-acme: "true"

    hosts:

    - host: jitsi.local

      paths: ['/']

    tls: []

    #  - secretName: jitsi-web-certificate

    #    hosts:

    #      - jitsi.local



  # Useful for ingresses that don't support http-to-https redirect by themself, (namely: GKE),

  httpRedirect: false



  # When tls-termination by the ingress is not wanted, enable this and set web.service.type=Loadbalancer


  httpsEnabled: false



  livenessProbe:

    httpGet:

      path: /

      port: 80

  readinessProbe:

    httpGet:

      path: /

      port: 80



  podLabels: {}

  podAnnotations: {}

  podSecurityContext: {}

    # fsGroup: 2000



  securityContext: {}

    # capabilities:

    #   drop:

    #   - ALL

    # readOnlyRootFilesystem: true

    # runAsNonRoot: true

    # runAsUser: 1000



  resources: {}

    # We usually recommend not to specify default resources and to leave this as a conscious

    # choice for the user. This also increases chances charts run on environments with little

    # resources, such as Minikube. If you do want to specify resources, uncomment the following

    # lines, adjust them as necessary, and remove the curly braces after 'resources:'.

    # limits:

    #   cpu: 100m

    #   memory: 128Mi

    # requests:

    #   cpu: 100m

    #   memory: 128Mi



  nodeSelector: {}



  tolerations: []



  affinity: {}



jicofo:

  replicaCount: 1

  image:

    repository: jitsi/jicofo
    tag: "stable-6433"


  xmpp:

    user: focus

    password:

    componentSecret:


  livenessProbe:

    tcpSocket:

      port: 8888

  readinessProbe:

    tcpSocket:

      port: 8888



  podLabels: {}

  podAnnotations: {}

  podSecurityContext: {}

  securityContext: {}

  resources: {}

  nodeSelector: {}

  tolerations: []

  affinity: {
          # podAntiAffinity:
                # requiredDuringSchedulingIgnoredDuringExecution:
                  #- labelSelector:
                  #matchExpressions:
                      # - key: node
                #operator: In
                #     values:
                        # - nsl-dev-on-demand
                  #            topologyKey: "kubernetes.io/hostname"
                  #nodeAffinity:
                  #requiredDuringSchedulingIgnoredDuringExecution:
                  #nodeSelectorTerms:
                  #- matchExpressions:
                  #- key: node
                  #operator: In
                  #values:
                  #- nsl-dev-on-demand

  }

  extraEnvs: {}



jvb:

  replicaCount: 1

  image:

    repository: jitsi/jvb
    tag: "stable-6433"

  xmpp:

    user: jvb

    password:



  stunServers: 'meet-jit-si-turnrelay.jitsi.net:443'

  useHostPort: false

  enableTCP: true

  UDPPort: 31500
  #publicIP: 'jitsi-dev-NLB-1c6ec6c1bd8a53a9.elb.ap-south-1.amazonaws.com'
  #publicIP: 15.206.140.224
  #TCPPort: 4443
  #enableTCP: true
  TCPPort: 31400
  #publicIP: arn:aws:elasticloadbalancing:ap-south-1:660124699787:loadbalancer/app/int-Internal-ALB/46e23189b8f0cb79
  service:

    enabled:
    type: NodePort

    externalIPs: []

    ## Annotations to be added to the service (if LoadBalancer is used)

    ##

    annotations: {}



  breweryMuc: jvbbrewery



  livenessProbe:

    httpGet:

      path: /about/health

      port: 8080

  readinessProbe:

    httpGet:

      path: /about/health

      port: 8080



  podLabels: {}

  podAnnotations: {}

  podSecurityContext: {}

  securityContext: {}

  resources: {}

  nodeSelector: {}

  tolerations: []

  affinity: {}

  extraEnvs: {}
  #    HOSTNAME : "xmpp.meet.jitsi"



  metrics:

    enabled: false

    image:

      repository: docker.io/systemli/prometheus-jitsi-meet-exporter

      tag: 1.1.6

      pullPolicy: IfNotPresent

    serviceMonitor:

      enabled: true

      selector:

        release: prometheus-operator

      interval: 10s

    resources:

      requests:

        cpu: 10m

        memory: 16Mi

      limits:

        cpu: 20m

        memory: 32Mi



serviceAccount:

  # Specifies whether a service account should be created

  create: true

  # Annotations to add to the service account

  annotations: {}

  # The name of the service account to use.

  # If not set and create is true, a name is generated using the fullname template

  name:



xmpp:

  domain: meet.jitsi

  authDomain:

  mucDomain:

  internalMucDomain:

  guestDomain:



extraCommonEnvs:
  ENABLE_XMPP_WEBSOCKET: "0"
  # HOSTNAME : "xmpp.meet.jitsi"

prosody:

  enabled: true

  server:

  extraEnvFrom:

  - secretRef:

      name: '{{ include "prosody.fullname" . }}-jicofo'

  - secretRef:

      name: '{{ include "prosody.fullname" . }}-jvb'

  - configMapRef:

      name: '{{ include "prosody.fullname" . }}-common'

  image:

    repository: jitsi/prosody

    tag: "stable-6433"